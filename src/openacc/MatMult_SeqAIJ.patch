--- ../original/MatMult_SeqAIJ.c	2017-08-03 18:16:43.985947000 -0400
+++ MatMult_SeqAIJ.c	2017-08-02 05:28:53.366142000 -0400
@@ -5,2 +5,8 @@
 
+// OpenACC header
+# include <openacc.h>
+
+PetscScalar single_row_mult(const PetscInt n, const PetscInt *cols, 
+        const MatScalar *data, const PetscScalar *x);
+
 #undef __FUNCT__
@@ -48,10 +54,73 @@
 #else
-    for (i=0; i<m; i++) {
-      n           = ii[i+1] - ii[i];
-      aj          = a->j + ii[i];
-      aa          = a->a + ii[i];
-      sum         = 0.0;
-      PetscSparseDensePlusDot(sum,x,aa,aj,n);
-      y[i] = sum;
+
+    // OpenACC starts here
+
+    PetscInt xSize, ySize;
+
+    ierr = VecGetLocalSize(xx, &xSize); CHKERRQ(ierr);
+    ierr = VecGetLocalSize(yy, &ySize); CHKERRQ(ierr);
+
+    ii = a->i;
+    aj = a->j;
+    aa = a->a;
+
+    # pragma acc wait(1)
+    # pragma acc enter data copyin(ii[:m+1]) async(1)
+    # pragma acc enter data copyin(aj[:a->nz]) async(1)
+    # pragma acc enter data copyin(aa[:a->nz]) async(1)
+
+    # pragma acc enter data copyin(x[:xSize]) async(1)
+
+    PetscInt present = 0;
+    PetscInt current = 0;
+
+    while((! acc_async_test_all()) && (current < m))
+    {
+      y[current] = single_row_mult(
+              ii[current+1]-ii[current], aj+ii[current], aa+ii[current], x);
+      current += 1;
+    }
+
+    int sizeBlock = 128 * 16 * 280;
+    int nBlocks = (m - current) / sizeBlock;
+
+    for(PetscInt b=0; b<nBlocks; ++b)
+    {
+      PetscInt bStart = current + b * sizeBlock;
+      PetscInt bEnd = bStart + sizeBlock;
+      PetscInt csrStart = ii[bStart];
+      PetscInt csrSize = ii[bEnd] - csrStart;
+
+      # pragma acc kernels loop independent gang vector(32) \
+        present(ii[bStart:sizeBlock+1]) \
+        present(aj[csrStart:csrSize]) \
+        present(aa[csrStart:csrSize]) \
+        present(x[:xSize]) \
+        copyout(y[bStart:sizeBlock]) \
+        async(b+1)
+      for(PetscInt _i=bStart; _i<bEnd; ++_i)
+        y[_i] = single_row_mult(ii[_i+1]-ii[_i], aj+ii[_i], aa+ii[_i], x);
+    }
+
+    if (((m - current) % sizeBlock) != 0)
+    {
+      PetscInt bStart = current + nBlocks * sizeBlock;
+      sizeBlock = m - bStart;
+      PetscInt csrStart = ii[bStart];
+      PetscInt csrSize = ii[m] - csrStart;
+
+      # pragma acc kernels loop independent gang vector(32) \
+        present(ii[bStart:sizeBlock+1]) \
+        present(aj[csrStart:csrSize]) \
+        present(aa[csrStart:csrSize]) \
+        present(x[:xSize]) \
+        copyout(y[bStart:sizeBlock]) \
+        async(nBlocks+1)
+      for(PetscInt _i=bStart; _i<m; ++_i)
+        y[_i] = single_row_mult(ii[_i+1]-ii[_i], aj+ii[_i], aa+ii[_i], x);
     }
+    # pragma acc wait
+    # pragma acc exit data delete(x[:xSize]) async
+    // OpenACC ends here
+
 #endif
@@ -63 +132,13 @@
 }
+
+# pragma acc routine seq
+PetscScalar single_row_mult(const PetscInt n, const PetscInt *cols, 
+        const MatScalar *data, const PetscScalar *x)
+{
+    PetscScalar s = 0;
+
+    for (PetscInt i=0; i<n; ++i)
+        s += data[i] * x[cols[i]];
+
+    return s;
+}
